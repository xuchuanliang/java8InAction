#引入流
- 流允许你以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）
- 流还可以透明的并行处理，无需编写任何多线程代码
- 流的目的在于表达计算，集合的目的在于数据
-         List<String> threeHighCaloricDishNames = menu.stream().
                  filter(d->d.getCalories()>30).
                  map(Dish::getName).
                  limit(3).
                  collect(Collectors.toList()); 
- filter：接受一个lambda，从流中排除某些元素
- map:接受一个lambda，将元素转换成其他形式或提取信息
- limit：截断流，使其元素不超过给定数量
- collect：将流转换为其他形式
- 集合和流之间的差异在于什么时候进行计算。集合是一个内存中的数据结构，它包含数据结构中目前所有的值--集合中的每一个元素都得先算出来才能添加到集合中。（你可以往集合中加东西或删除东西，但是不管什么时候，集合中的每个元素都是放在内存中的，
元素都得先算出来才能成为集合的一部分）；相比之下，流则是在概念下固定的数据结构（你不能添加或删除元素），其元素则是按需计算。流像一个延迟创建的集合：只有在消费需求的时候才会计算值。
- 流和迭代器一样，只能遍历一次。遍历完后，这个流就已经被消费掉了，可以从原始数据获取新的流再处理。流只能被消费一次
- 集合和流的另一个区别是遍历数据的方式不同，流是使用内部迭代，集合是使用外部迭代。
- java.util.stream.Stream中定义的操作主要分为两类：可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作。
- 中间操作会返回一个流，这让多个操作可以连接起来形成一个查询。重要的是，除非流水线上触发一个终端操作，否则中间操作不会做任何处理，这是因为中间操作一般可以合并起来，在终端操作时一次性全部处理
- 流的使用一般包括三件事：一个数据源（如集合）来执行一个查询；一个中间操作链，形成一条流水线；一个中断操作，执行流水线，并能生成结果。
- 流的distinct方法：会返回一个元素各异的流（hashCode和equals放方法的实现）
- 流的limit方法，截断流，会返回一个不超过给定长度的流
- 流的skip方法，跳过元素，返回一个扔掉了前n个元素的流，如果流中的元素不足n个，则返回一个空流


